# -*- coding: utf-8 -*-
"""AI-Powered Code Review Assistant.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mSJWqBn2lTR4rVdDPTOE7GcjLd--U9XE
"""

!pip install -q flask flask-cors google-generativeai langchain langchain-google-genai
!pip install -q ast-decompiler radon pylint bandit
!pip install -q gradio  # For easy web interface in Colab

import ast
import re
import os
import json
import time
from dataclasses import dataclass
from typing import List, Dict, Any, Optional
import google.generativeai as genai
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
import gradio as gr
import radon.complexity as complexity
import radon.metrics as metrics

GEMINI_API_KEY = "AIzaSyB6g0X92W28t-aF8HAonf4FBMvOIOL9JbE"  # Replace with your actual API key

if GEMINI_API_KEY != "AIzaSyB6g0X92W28t-aF8HAonf4FBMvOIOL9JbE":
    genai.configure(api_key=GEMINI_API_KEY)
    llm = ChatGoogleGenerativeAI(model="gemini-pro", google_api_key=GEMINI_API_KEY)
else:
    print("‚ö†Ô∏è Please add your Gemini API key to enable AI features")
    llm = None

@dataclass
class CodeIssue:
    type: str
    severity: str  # 'high', 'medium', 'low'
    line_number: int
    message: str
    suggestion: str
    code_snippet: str

@dataclass
class CodeMetrics:
    lines_of_code: int
    cyclomatic_complexity: float
    maintainability_index: float
    functions_count: int
    classes_count: int

@dataclass
class CodeReviewResult:
    overall_score: float  # 0-10
    metrics: CodeMetrics
    issues: List[CodeIssue]
    ai_suggestions: List[str]
    security_alerts: List[str]

class StaticCodeAnalyzer:
    def __init__(self):
        self.issues = []

    def analyze_python_code(self, code: str) -> List[CodeIssue]:
        """Perform static analysis on Python code"""
        self.issues = []

        try:
            # Parse the code into AST
            tree = ast.parse(code)

            # Analyze different aspects
            self._check_naming_conventions(tree, code)
            self._check_function_complexity(tree, code)
            self._check_code_smells(tree, code)
            self._check_best_practices(tree, code)

        except SyntaxError as e:
            self.issues.append(CodeIssue(
                type="syntax_error",
                severity="high",
                line_number=e.lineno or 1,
                message=f"Syntax Error: {e.msg}",
                suggestion="Fix the syntax error before proceeding with analysis",
                code_snippet=""
            ))

        return self.issues

    def _check_naming_conventions(self, tree: ast.AST, code: str):
        """Check Python naming conventions"""
        lines = code.split('\n')

        class NameChecker(ast.NodeVisitor):
            def __init__(self, analyzer):
                self.analyzer = analyzer
                self.lines = lines

            def visit_FunctionDef(self, node):
                # Check function naming (should be snake_case)
                if not re.match(r'^[a-z_][a-z0-9_]*$', node.name) and not node.name.startswith('__'):
                    self.analyzer.issues.append(CodeIssue(
                        type="naming_convention",
                        severity="medium",
                        line_number=node.lineno,
                        message=f"Function '{node.name}' should use snake_case naming",
                        suggestion=f"Rename to: {self._to_snake_case(node.name)}",
                        code_snippet=self.lines[node.lineno-1] if node.lineno <= len(self.lines) else ""
                    ))
                self.generic_visit(node)

            def visit_ClassDef(self, node):
                # Check class naming (should be PascalCase)
                if not re.match(r'^[A-Z][A-Za-z0-9]*$', node.name):
                    self.analyzer.issues.append(CodeIssue(
                        type="naming_convention",
                        severity="medium",
                        line_number=node.lineno,
                        message=f"Class '{node.name}' should use PascalCase naming",
                        suggestion=f"Rename to: {self._to_pascal_case(node.name)}",
                        code_snippet=self.lines[node.lineno-1] if node.lineno <= len(self.lines) else ""
                    ))
                self.generic_visit(node)

            def _to_snake_case(self, name):
                return re.sub('([A-Z])', r'_\1', name).lower().lstrip('_')

            def _to_pascal_case(self, name):
                return ''.join(word.capitalize() for word in name.split('_'))

        NameChecker(self).visit(tree)

    def _check_function_complexity(self, tree: ast.AST, code: str):
        """Check function complexity"""
        lines = code.split('\n')

        class ComplexityChecker(ast.NodeVisitor):
            def __init__(self, analyzer):
                self.analyzer = analyzer
                self.lines = lines

            def visit_FunctionDef(self, node):
                # Count nested statements as complexity indicator
                complexity_score = self._calculate_complexity(node)

                if complexity_score > 10:
                    self.analyzer.issues.append(CodeIssue(
                        type="high_complexity",
                        severity="high",
                        line_number=node.lineno,
                        message=f"Function '{node.name}' has high complexity ({complexity_score})",
                        suggestion="Consider breaking this function into smaller, more focused functions",
                        code_snippet=self.lines[node.lineno-1] if node.lineno <= len(self.lines) else ""
                    ))
                elif complexity_score > 6:
                    self.analyzer.issues.append(CodeIssue(
                        type="medium_complexity",
                        severity="medium",
                        line_number=node.lineno,
                        message=f"Function '{node.name}' has moderate complexity ({complexity_score})",
                        suggestion="Consider simplifying or adding comments for better readability",
                        code_snippet=self.lines[node.lineno-1] if node.lineno <= len(self.lines) else ""
                    ))

                self.generic_visit(node)

            def _calculate_complexity(self, node):
                complexity = 1
                for child in ast.walk(node):
                    if isinstance(child, (ast.If, ast.For, ast.While, ast.With)):
                        complexity += 1
                    elif isinstance(child, ast.ExceptHandler):
                        complexity += 1
                return complexity

        ComplexityChecker(self).visit(tree)

    def _check_code_smells(self, tree: ast.AST, code: str):
        """Detect common code smells"""
        lines = code.split('\n')

        # Check for long lines
        for i, line in enumerate(lines, 1):
            if len(line) > 100:
                self.issues.append(CodeIssue(
                    type="long_line",
                    severity="low",
                    line_number=i,
                    message="Line exceeds 100 characters",
                    suggestion="Break long lines for better readability (PEP 8 recommends max 79 chars)",
                    code_snippet=line[:50] + "..." if len(line) > 50 else line
                ))

        # Check for TODO/FIXME comments
        for i, line in enumerate(lines, 1):
            if re.search(r'#.*\b(TODO|FIXME|HACK)\b', line, re.IGNORECASE):
                self.issues.append(CodeIssue(
                    type="todo_comment",
                    severity="low",
                    line_number=i,
                    message="Found TODO/FIXME comment",
                    suggestion="Consider addressing this technical debt",
                    code_snippet=line.strip()
                ))

    def _check_best_practices(self, tree: ast.AST, code: str):
        """Check Python best practices"""
        lines = code.split('\n')

        class BestPracticeChecker(ast.NodeVisitor):
            def __init__(self, analyzer):
                self.analyzer = analyzer
                self.lines = lines

            def visit_FunctionDef(self, node):
                # Check for missing docstrings
                if not ast.get_docstring(node):
                    self.analyzer.issues.append(CodeIssue(
                        type="missing_docstring",
                        severity="medium",
                        line_number=node.lineno,
                        message=f"Function '{node.name}' missing docstring",
                        suggestion="Add a docstring describing the function's purpose, parameters, and return value",
                        code_snippet=self.lines[node.lineno-1] if node.lineno <= len(self.lines) else ""
                    ))

                # Check for too many parameters
                if len(node.args.args) > 5:
                    self.analyzer.issues.append(CodeIssue(
                        type="too_many_parameters",
                        severity="medium",
                        line_number=node.lineno,
                        message=f"Function '{node.name}' has {len(node.args.args)} parameters",
                        suggestion="Consider using a class or reducing parameters for better maintainability",
                        code_snippet=self.lines[node.lineno-1] if node.lineno <= len(self.lines) else ""
                    ))

                self.generic_visit(node)

            def visit_Import(self, node):
                # Check for unused imports (basic check)
                for alias in node.names:
                    self.analyzer.issues.append(CodeIssue(
                        type="import_info",
                        severity="low",
                        line_number=node.lineno,
                        message=f"Import: {alias.name}",
                        suggestion="Ensure this import is actually used in the code",
                        code_snippet=self.lines[node.lineno-1] if node.lineno <= len(self.lines) else ""
                    ))
                self.generic_visit(node)

        BestPracticeChecker(self).visit(tree)

class AICodeReviewer:
    def __init__(self, llm):
        self.llm = llm
        self.setup_prompts()

    def setup_prompts(self):
        """Setup AI prompts for different types of analysis"""

        self.code_review_prompt = PromptTemplate(
            input_variables=["code", "issues"],
            template="""
            You are an expert software engineer performing a code review. Analyze the following Python code:

            CODE:
            ```python
            {code}
            ```

            EXISTING ISSUES FOUND:
            {issues}

            Please provide:
            1. 3-5 specific improvement suggestions beyond the issues already found
            2. Security considerations if any
            3. Performance optimization opportunities
            4. Code organization and architecture feedback
            5. Overall code quality assessment (1-10 scale)

            Focus on actionable, specific suggestions that would make this code production-ready.
            """
        )

        self.security_analysis_prompt = PromptTemplate(
            input_variables=["code"],
            template="""
            Analyze the following Python code for security vulnerabilities:

            ```python
            {code}
            ```

            Look for:
            - SQL injection possibilities
            - Input validation issues
            - Hardcoded secrets or passwords
            - Unsafe file operations
            - Command injection risks
            - Authentication/authorization flaws

            Provide specific security recommendations with severity levels.
            """
        )

    def get_ai_suggestions(self, code: str, existing_issues: List[CodeIssue]) -> List[str]:
        """Get AI-powered code improvement suggestions"""
        if not self.llm:
            return ["AI analysis unavailable - please configure Gemini API key"]

        try:
            issues_summary = "\n".join([f"- {issue.message}" for issue in existing_issues[:10]])

            chain = LLMChain(llm=self.llm, prompt=self.code_review_prompt)
            response = chain.run(code=code, issues=issues_summary)

            # Parse response into suggestions
            suggestions = [s.strip() for s in response.split('\n') if s.strip() and not s.strip().startswith('#')]
            return suggestions[:8]  # Limit to top 8 suggestions

        except Exception as e:
            return [f"AI analysis error: {str(e)}"]

    def get_security_analysis(self, code: str) -> List[str]:
        """Get security-focused analysis"""
        if not self.llm:
            return ["Security analysis unavailable - please configure Gemini API key"]

        try:
            chain = LLMChain(llm=self.llm, prompt=self.security_analysis_prompt)
            response = chain.run(code=code)

            alerts = [s.strip() for s in response.split('\n') if s.strip() and ('vulnerability' in s.lower() or 'security' in s.lower() or 'risk' in s.lower())]
            return alerts[:5]  # Top 5 security concerns

        except Exception as e:
            return [f"Security analysis error: {str(e)}"]

# ============================================================================
# SECTION 6: MAIN CODE REVIEW ENGINE
# ============================================================================

class CodeReviewAssistant:
    def __init__(self):
        self.static_analyzer = StaticCodeAnalyzer()
        self.ai_reviewer = AICodeReviewer(llm) if llm else None

    def analyze_code(self, code: str) -> CodeReviewResult:
        """Perform comprehensive code analysis"""
        print("üîç Starting code analysis...")

        # Step 1: Static Analysis
        print("üìä Running static analysis...")
        issues = self.static_analyzer.analyze_python_code(code)

        # Step 2: Calculate Metrics
        print("üìà Calculating metrics...")
        metrics_data = self._calculate_metrics(code)

        # Step 3: AI Analysis
        ai_suggestions = []
        security_alerts = []

        if self.ai_reviewer:
            print("ü§ñ Running AI analysis...")
            ai_suggestions = self.ai_reviewer.get_ai_suggestions(code, issues)
            security_alerts = self.ai_reviewer.get_security_analysis(code)
        else:
            ai_suggestions = ["Configure Gemini API key for AI-powered suggestions"]

        # Step 4: Calculate Overall Score
        overall_score = self._calculate_overall_score(issues, metrics_data)

        print("‚úÖ Analysis complete!")

        return CodeReviewResult(
            overall_score=overall_score,
            metrics=metrics_data,
            issues=issues,
            ai_suggestions=ai_suggestions,
            security_alerts=security_alerts
        )

    def _calculate_metrics(self, code: str) -> CodeMetrics:
        """Calculate code metrics"""
        lines = code.split('\n')
        lines_of_code = len([line for line in lines if line.strip() and not line.strip().startswith('#')])

        try:
            # Use radon for complexity analysis
            complexity_data = complexity.cc_visit(code)
            avg_complexity = sum(item.complexity for item in complexity_data) / max(len(complexity_data), 1)

            # Count functions and classes
            tree = ast.parse(code)
            functions_count = len([node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)])
            classes_count = len([node for node in ast.walk(tree) if isinstance(node, ast.ClassDef)])

            # Simple maintainability index calculation
            maintainability = max(0, 100 - avg_complexity * 5 - lines_of_code * 0.1)

        except:
            avg_complexity = 1.0
            functions_count = 0
            classes_count = 0
            maintainability = 50.0

        return CodeMetrics(
            lines_of_code=lines_of_code,
            cyclomatic_complexity=avg_complexity,
            maintainability_index=maintainability,
            functions_count=functions_count,
            classes_count=classes_count
        )

    def _calculate_overall_score(self, issues: List[CodeIssue], metrics: CodeMetrics) -> float:
        """Calculate overall code quality score (0-10)"""
        base_score = 10.0

        # Deduct points for issues
        for issue in issues:
            if issue.severity == "high":
                base_score -= 1.5
            elif issue.severity == "medium":
                base_score -= 0.8
            else:
                base_score -= 0.3

        # Adjust for complexity
        if metrics.cyclomatic_complexity > 10:
            base_score -= 1.0
        elif metrics.cyclomatic_complexity > 6:
            base_score -= 0.5

        # Ensure score is between 0-10
        return max(0.0, min(10.0, round(base_score, 1)))

def create_demo_interface():
    """Create Gradio interface for the code review assistant"""

    reviewer = CodeReviewAssistant()

    def analyze_code_interface(code_input):
        """Interface function for Gradio"""
        if not code_input.strip():
            return "Please enter some Python code to analyze.", "", "", "", ""

        try:
            result = reviewer.analyze_code(code_input)

            # Format results
            overview = f"""
## üìä Code Quality Score: {result.overall_score}/10

### üìà Metrics:
- **Lines of Code:** {result.metrics.lines_of_code}
- **Cyclomatic Complexity:** {result.metrics.cyclomatic_complexity:.1f}
- **Maintainability Index:** {result.metrics.maintainability_index:.1f}%
- **Functions:** {result.metrics.functions_count}
- **Classes:** {result.metrics.classes_count}
            """

            # Format issues
            issues_text = "## üîç Issues Found:\n\n"
            if result.issues:
                for i, issue in enumerate(result.issues[:10], 1):
                    severity_emoji = {"high": "üî¥", "medium": "üü°", "low": "üîµ"}[issue.severity]
                    issues_text += f"{i}. {severity_emoji} **{issue.type.replace('_', ' ').title()}** (Line {issue.line_number})\n"
                    issues_text += f"   - {issue.message}\n"
                    issues_text += f"   - *Suggestion: {issue.suggestion}*\n\n"
            else:
                issues_text += "‚úÖ No issues found!\n"

            # Format AI suggestions
            ai_text = "## ü§ñ AI Suggestions:\n\n"
            if result.ai_suggestions:
                for i, suggestion in enumerate(result.ai_suggestions[:5], 1):
                    if suggestion.strip():
                        ai_text += f"{i}. {suggestion}\n\n"
            else:
                ai_text += "No AI suggestions available.\n"

            # Format security alerts
            security_text = "## üîí Security Analysis:\n\n"
            if result.security_alerts:
                for i, alert in enumerate(result.security_alerts, 1):
                    if alert.strip():
                        security_text += f"{i}. {alert}\n\n"
            else:
                security_text += "No security concerns detected.\n"

            # Generate improvement recommendations
            recommendations = f"""
## üéØ Improvement Recommendations:

Based on your code analysis (Score: {result.overall_score}/10):

{'üü¢ **Excellent Code Quality!**' if result.overall_score >= 8 else
 'üü° **Good Code with Room for Improvement**' if result.overall_score >= 6 else
 'üî¥ **Needs Significant Improvement**'}

### Priority Actions:
1. Address any HIGH severity issues first
2. {'Add docstrings to functions' if any(issue.type == 'missing_docstring' for issue in result.issues) else 'Consider adding more comprehensive documentation'}
3. {'Reduce function complexity' if result.metrics.cyclomatic_complexity > 6 else 'Maintain current code simplicity'}
4. {'Follow Python naming conventions' if any('naming' in issue.type for issue in result.issues) else 'Good naming practices observed'}

### Next Steps for Resume Project:
- ‚úÖ Implement user feedback system
- ‚úÖ Add GitHub integration
- ‚úÖ Create analytics dashboard
- ‚úÖ Deploy with Flask/FastAPI backend
            """

            return overview, issues_text, ai_text, security_text, recommendations

        except Exception as e:
            error_msg = f"Analysis failed: {str(e)}"
            return error_msg, "", "", "", ""

    # Create Gradio interface
    demo = gr.Interface(
        fn=analyze_code_interface,
        inputs=[
            gr.Textbox(
                lines=20,
                placeholder="Paste your Python code here...",
                label="Python Code to Analyze"
            )
        ],
        outputs=[
            gr.Markdown(label="üìä Overview & Metrics"),
            gr.Markdown(label="üîç Issues & Suggestions"),
            gr.Markdown(label="ü§ñ AI Recommendations"),
            gr.Markdown(label="üîí Security Analysis"),
            gr.Markdown(label="üéØ Project Recommendations")
        ],
        title="ü§ñ AI-Powered Code Review Assistant",
        description="""
        **Created by Ankit Singh** - Advanced AI Code Review System

        This tool performs comprehensive code analysis including:
        - Static code analysis for bugs and code smells
        - AI-powered improvement suggestions
        - Security vulnerability detection
        - Code quality metrics and scoring

        Perfect for improving code quality and learning best practices!
        """,
        examples=[
            ["""
def calculate_factorial(n):
    if n == 0:
        return 1
    else:
        return n * calculate_factorial(n-1)

def main():
    number = 5
    result = calculate_factorial(number)
    print(f"Factorial of {number} is {result}")

if __name__ == "__main__":
    main()
            """],
            ["""
import os
import sqlite3

class UserManager:
    def __init__(self, db_path):
        self.db_path = db_path
        self.connection = sqlite3.connect(db_path)

    def authenticate_user(self, username, password):
        query = f"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'"
        cursor = self.connection.execute(query)
        return cursor.fetchone() is not None

    def create_user(self, username, password, email):
        query = f"INSERT INTO users VALUES ('{username}', '{password}', '{email}')"
        self.connection.execute(query)
        self.connection.commit()
            """]
        ],
        theme=gr.themes.Soft()
    )

    return demo

if __name__ == "__main__":
    print("üöÄ AI-Powered Code Review Assistant")
    print("=" * 50)

    # Display setup instructions
    if GEMINI_API_KEY == "AIzaSyB6g0X92W28t-aF8HAonf4FBMvOIOL9JbE":
        print("‚ö†Ô∏è  SETUP REQUIRED:")
        print("1. Get your free Gemini API key from: https://makersuite.google.com/app/apikey")
        print("2. Replace 'YOUR_GEMINI_API_KEY_HERE' with your actual API key")
        print("3. Re-run the notebook for full AI-powered analysis")
        print("\nüîÑ Running with static analysis only for now...\n")

    # Create and launch the demo
    demo = create_demo_interface()

    # Launch the interface
    print("üåê Launching web interface...")
    demo.launch(share=True, debug=True)

    print("\n‚úÖ Code Review Assistant is ready!")
    print("üí° Try pasting some Python code to see the magic happen!")

    # Example usage for testing
    sample_code = '''
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

def main():
    for i in range(10):
        print(f"F({i}) = {fibonacci(i)}")

if __name__ == "__main__":
    main()
    '''

    print(f"\nüß™ Testing with sample code...")
    reviewer = CodeReviewAssistant()
    result = reviewer.analyze_code(sample_code)
    print(f"‚úÖ Sample analysis complete! Score: {result.overall_score}/10")

